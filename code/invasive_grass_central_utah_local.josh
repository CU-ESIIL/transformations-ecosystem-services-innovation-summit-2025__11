start simulation Main

  # Central Utah Location - Sevier County region (critical sagebrush steppe ecosystem)
  grid.size = 3000 m
  grid.low = 38.13405812765913 degrees latitude, -112.14025074471213 degrees longitude
  grid.high = 38.50575673940446 degrees latitude, -111.56007899393265 degrees longitude

  # Simulation timeframe: 2030-2050 for educational efficiency
  steps.low = 0 count
  steps.high = 20 count

  startYear.init = 2030
  year.init = startYear
  year.step = prior.year + 1

  # Export configuration - save to memory for browser-based educational use
  exportFiles.patch = "file://result.csv"

  # Fire probability parameters (Central Utah specific)
  fire.base.probability = 1.8%
  fire.temperature.threshold = 32 degrees
  fire.temperature.modifier = 0.15%
  fire.precipitation.threshold = 100 mm
  fire.precipitation.modifier = 0.8%
  fire.invasive.coverage.modifier = 0.25%

  # Species flammability multipliers
  fire.invasive.multiplier = 4.0 count
  fire.native.multiplier = 1.0 count
  fire.shrub.multiplier = 2.0 count

  # Fire damage parameters - ensures vegetation is cleared when on fire
  fire.damage.invasive = 100%
  fire.damage.native = 98%
  fire.damage.shrub = 95%

  # Management effectiveness parameters
  # Mechanical thinning affects both native and invasive (realistic for mowing/cutting)
  mechanical.invasive.reduction = 65%    # High effectiveness on invasive
  mechanical.native.reduction = 10%      # Affects native (collateral damage from mowing)
  mechanical.shrub.reduction = 5%        # Minor impact on shrubs (they can resprout)
  
  reseeding.success.rate = 50%
  drought.resistant.fire.reduction = 30%
  drought.resistant.establishment.multiplier = 2.5 count
  herbicide.reduction = 40%
  herbicide.duration = 2 count

end simulation

start patch Default

  # Initialize with Central Utah appropriate starting conditions
  # Read initial occupancy from external data in first year only
  invasiveCover.start = external invasiveInitial if meta.year == meta.startYear else prior.invasiveCover
  nativeCover.start = external nativeInitial if meta.year == meta.startYear else prior.nativeCover
  shrubCover.start = external shrubInitial if meta.year == meta.startYear else prior.shrubCover

  # Management application tracking
  mechanicalTreatment.init = false
  reseedingTreatment.init = false
  droughtResistantTreatment.init = false
  herbicideTreatment.init = false
  herbicideYearsRemaining.init = 0 count

  # Calculate fire probability based on environmental conditions and coverage
  temperatureRisk.step = {
    const tempDiff = external temperature - meta.fire.temperature.threshold
    const tempContribution = tempDiff * meta.fire.temperature.modifier if tempDiff > 0 degrees else 0%
    return limit tempContribution to [0%, 10%]
  }

  precipitationRisk.step = {
    const precipDiff = meta.fire.precipitation.threshold - external precipitation
    const precipContribution = (precipDiff / 50 mm) * meta.fire.precipitation.modifier if precipDiff > 0 mm else 0%
    return limit precipContribution to [0%, 15%]
  }

  coverageRisk.step = (prior.invasiveCover / 10%) * meta.fire.invasive.coverage.modifier

  managementReduction.step = meta.drought.resistant.fire.reduction if prior.droughtResistantTreatment else 0%

  fireProbability.step = {
    const baseRisk = meta.fire.base.probability + temperatureRisk + precipitationRisk + coverageRisk
    const adjustedRisk = baseRisk * (1 - managementReduction / 100%)
    return limit adjustedRisk to [0%, 25%]
  }

  onFire.step = (sample uniform from 0% to 100%) < fireProbability

  # Calculate species growth rates based on summer precipitation
  # Aggressive invasive species: High growth rates and drought tolerance
  invasiveGrowth.step = map external precipitation from [40 mm, 140 mm] to [12%, 35%] sigmoid
  nativeGrowth.step = {
    const regularGrowth = map external precipitation from [60 mm, 120 mm] to [3%, 15%] sigmoid
    const reseedBonus = (sample uniform from 0% to 2%) if prior.reseedingTreatment else 0%
    return regularGrowth + reseedBonus
  }
  shrubGrowth.step = map external precipitation from [70 mm, 110 mm] to [1%, 8%] sigmoid

  # Calculate spread rates (colonization of empty space)
  emptySpace.step = limit (100% - prior.invasiveCover - prior.nativeCover - prior.shrubCover) to [0%, 100%]

  # Aggressive invasive species: High spread rates and establishment success
  invasiveSpread.step = {
    const maxSpread = emptySpace * 45% / 100%  # High spread rate
    const precipModifier = map external precipitation from [30 mm, 100 mm] to [0.5, 1.2] linear  # Drought tolerance
    return maxSpread * precipModifier
  }

  nativeSpread.step = {
    const maxSpread = emptySpace * 9% / 100%
    const precipModifier = map external precipitation from [50 mm, 100 mm] to [0.2, 1.0] linear
    const reseedingBonus = meta.reseeding.success.rate if prior.reseedingTreatment else 0%
    const droughtBonus = meta.drought.resistant.establishment.multiplier if prior.droughtResistantTreatment else 1 count
    return maxSpread * precipModifier * droughtBonus + (emptySpace * reseedingBonus / 100%)
  }

  shrubSpread.step = {
    const maxSpread = emptySpace * 5% / 100%
    const precipModifier = map external precipitation from [60 mm, 110 mm] to [0.1, 0.8] linear
    return maxSpread * precipModifier
  }

  # Apply management treatments (simplified annual application)
  mechanicalTreatment.step = (sample uniform from 0% to 100%) < config editor.mechanicalCoverage
  reseedingTreatment.step = (sample uniform from 0% to 100%) < config editor.reseedingCoverage
  droughtResistantTreatment.step = (sample uniform from 0% to 100%) < config editor.droughtResistantCoverage
  herbicideTreatment.step = (sample uniform from 0% to 100%) < config editor.herbicideCoverage

  # Update herbicide duration tracking
  herbicideYearsRemaining.step = {
    if (herbicideTreatment) {
      return meta.herbicide.duration
    } elif (prior.herbicideYearsRemaining > 0 count) {
      return prior.herbicideYearsRemaining - 1 count
    } else {
      return 0 count
    }
  }

  # Calculate fire damage - ensuring complete vegetation clearing
  invasiveDestruction.step = sample normal with mean of meta.fire.damage.invasive std of 5%
  nativeDestruction.step = sample normal with mean of meta.fire.damage.native std of 8%
  shrubDestruction.step = sample normal with mean of meta.fire.damage.shrub std of 12%

  # Apply management effects - mechanical treatment affects all species
  mechanicalInvasiveReduction.step = meta.mechanical.invasive.reduction if mechanicalTreatment else 0%
  mechanicalNativeReduction.step = meta.mechanical.native.reduction if mechanicalTreatment else 0%
  mechanicalShrubReduction.step = meta.mechanical.shrub.reduction if mechanicalTreatment else 0%
  
  herbicideReduction.step = meta.herbicide.reduction if herbicideYearsRemaining > 0 count else 0%

  # Total reductions for each species
  totalInvasiveReduction.step = limit (mechanicalInvasiveReduction + herbicideReduction) to [0%, 98%]
  totalNativeReduction.step = mechanicalNativeReduction  # Only mechanical affects native
  totalShrubReduction.step = mechanicalShrubReduction    # Only mechanical affects shrub

  # Update species coverage - fire damage applied first to ensure clearing
  invasiveCover.step = {
    # Apply fire damage first (ensures fire clears vegetation)
    const afterFire = prior.invasiveCover * (1 - invasiveDestruction / 100%) if onFire else prior.invasiveCover
    # Then apply growth and spread to surviving vegetation
    const afterGrowth = afterFire + (afterFire * invasiveGrowth / 100%) + invasiveSpread
    # Finally apply management reductions
    const afterManagement = afterGrowth * (1 - totalInvasiveReduction / 100%)
    return limit afterManagement to [0%, 100%]
  }

  nativeCover.step = {
    # Apply fire damage first (ensures fire clears vegetation)
    const afterFire = prior.nativeCover * (1 - nativeDestruction / 100%) if onFire else prior.nativeCover
    # Then apply growth and spread to surviving vegetation
    const afterGrowth = afterFire + (afterFire * nativeGrowth / 100%) + nativeSpread
    # Finally apply management reductions (mechanical treatment affects native too)
    const afterManagement = afterGrowth * (1 - totalNativeReduction / 100%)
    return limit afterManagement to [0%, 100%]
  }

  shrubCover.step = {
    # Apply fire damage first (ensures fire clears vegetation)
    const afterFire = prior.shrubCover * (1 - shrubDestruction / 100%) if onFire else prior.shrubCover
    # Then apply growth and spread to surviving vegetation
    const afterGrowth = afterFire + (afterFire * shrubGrowth / 100%) + shrubSpread
    # Finally apply management reductions (mechanical treatment affects shrubs slightly)
    const afterManagement = afterGrowth * (1 - totalShrubReduction / 100%)
    return limit afterManagement to [0%, 100%]
  }

  # Calculate total coverage and adjust for overlap (competition for space)
  totalCover.step = invasiveCover + nativeCover + shrubCover

  # Normalize if total exceeds 100% (competition for space)
  # Invasive species have competitive advantage in space competition
  invasiveCover.end = {
    if (prior.totalCover > 100%) {
      const invasiveAdvantage = 1.1  # 10% competitive advantage
      const adjustedInvasive = prior.invasiveCover * invasiveAdvantage
      const adjustedTotal = adjustedInvasive + prior.nativeCover + prior.shrubCover
      return limit (adjustedInvasive * 100% / adjustedTotal) to [0%, 100%]
    } else {
      return prior.invasiveCover
    }
  }

  nativeCover.end = {
    if (prior.totalCover > 100%) {
      const invasiveAdvantage = 1.1
      const adjustedInvasive = prior.invasiveCover * invasiveAdvantage
      const adjustedTotal = adjustedInvasive + prior.nativeCover + prior.shrubCover
      return limit (prior.nativeCover * 100% / adjustedTotal) to [0%, 100%]
    } else {
      return prior.nativeCover
    }
  }

  shrubCover.end = {
    if (prior.totalCover > 100%) {
      const invasiveAdvantage = 1.1
      const adjustedInvasive = prior.invasiveCover * invasiveAdvantage
      const adjustedTotal = adjustedInvasive + prior.nativeCover + prior.shrubCover
      return limit (prior.shrubCover * 100% / adjustedTotal) to [0%, 100%]
    } else {
      return prior.shrubCover
    }
  }

  # Calculate ecosystem metrics for scoring
  carbonStorage.end = {
    const shrubCarbon = shrubCover * 310 / 100%
    const nativeCarbon = nativeCover * 140 / 100%
    const invasiveCarbon = invasiveCover * 120 / 100%
    return shrubCarbon + nativeCarbon + invasiveCarbon
  }

  nativeScore.end = (shrubCover * 1.2) + (nativeCover * 1.0)

  # Export key variables for analysis
  export.invasiveCover.end = invasiveCover
  export.nativeCover.end = nativeCover
  export.shrubCover.end = shrubCover
  export.fireProbability.end = fireProbability
  export.onFire.end = onFire
  export.carbonStorage.end = carbonStorage
  export.nativeScore.end = nativeScore
  export.precipitation.end = external precipitation
  export.temperature.end = external temperature
  export.mechanicalTreatment.end = mechanicalTreatment
  export.herbicideYearsRemaining.end = herbicideYearsRemaining

end patch
